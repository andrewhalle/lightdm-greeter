/* automatically generated by rust-bindgen 0.59.2 */

pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type gchar = ::std::os::raw::c_char;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type GQuark = guint32;
#[doc = " GError:"]
#[doc = " @domain: error domain, e.g. #G_FILE_ERROR"]
#[doc = " @code: error code, e.g. %G_FILE_ERROR_NOENT"]
#[doc = " @message: human-readable informative error message"]
#[doc = ""]
#[doc = " The `GError` structure contains information about"]
#[doc = " an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
pub type uid_t = __uid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
pub type GType = gsize;
#[doc = " GValue:"]
#[doc = ""]
#[doc = " An opaque structure used to hold different types of values."]
#[doc = ""]
#[doc = " The data within the structure has protected scope: it is accessible only"]
#[doc = " to functions within a #GTypeValueTable structure, or implementations of"]
#[doc = " the g_value_*() API. That is, code portions which implement new fundamental"]
#[doc = " types."]
#[doc = ""]
#[doc = " #GValue users cannot make any assumptions about how data is stored"]
#[doc = " within the 2 element @data union, and the @g_type member should"]
#[doc = " only be accessed through the G_VALUE_TYPE() macro."]
pub type GValue = _GValue;
#[doc = " GTypeClass:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInstance:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeClass:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeClass>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
#[doc = " GTypeInstance:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInstance>())).g_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
#[doc = " GValue:"]
#[doc = ""]
#[doc = " An opaque structure used to hold different types of values."]
#[doc = ""]
#[doc = " The data within the structure has protected scope: it is accessible only"]
#[doc = " to functions within a #GTypeValueTable structure, or implementations of"]
#[doc = " the g_value_*() API. That is, code portions which implement new fundamental"]
#[doc = " types."]
#[doc = ""]
#[doc = " #GValue users cannot make any assumptions about how data is stored"]
#[doc = " within the 2 element @data union, and the @g_type member should"]
#[doc = " only be accessed through the G_VALUE_TYPE() macro."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_long as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_ulong as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_ulong)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__GValue() {
    assert_eq!(
        ::std::mem::size_of::<_GValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(data)
        )
    );
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
#[doc = " GParamFlags:"]
#[doc = " @G_PARAM_READABLE: the parameter is readable"]
#[doc = " @G_PARAM_WRITABLE: the parameter is writable"]
#[doc = " @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE"]
#[doc = " @G_PARAM_CONSTRUCT: the parameter will be set upon object construction"]
#[doc = " @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction"]
#[doc = " @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())"]
#[doc = "  strict validation is not required"]
#[doc = " @G_PARAM_STATIC_NAME: the string used as name when constructing the"]
#[doc = "  parameter is guaranteed to remain valid and"]
#[doc = "  unmodified for the lifetime of the parameter."]
#[doc = "  Since 2.8"]
#[doc = " @G_PARAM_STATIC_NICK: the string used as nick when constructing the"]
#[doc = "  parameter is guaranteed to remain valid and"]
#[doc = "  unmmodified for the lifetime of the parameter."]
#[doc = "  Since 2.8"]
#[doc = " @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the"]
#[doc = "  parameter is guaranteed to remain valid and"]
#[doc = "  unmodified for the lifetime of the parameter."]
#[doc = "  Since 2.8"]
#[doc = " @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this"]
#[doc = "   property will not automatically result in a \"notify\" signal being"]
#[doc = "   emitted: the implementation must call g_object_notify() themselves"]
#[doc = "   in case the property actually changes.  Since: 2.42."]
#[doc = " @G_PARAM_PRIVATE: internal"]
#[doc = " @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed"]
#[doc = "  in a future version. A warning will be generated if it is used"]
#[doc = "  while running with G_ENABLE_DIAGNOSTIC=1."]
#[doc = "  Since 2.26"]
#[doc = ""]
#[doc = " Through the #GParamFlags flag values, certain aspects of parameters"]
#[doc = " can be configured."]
#[doc = ""]
#[doc = " See also: %G_PARAM_STATIC_STRINGS"]
pub type GParamFlags = ::std::os::raw::c_int;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)"]
#[doc = " @g_type_instance: private #GTypeInstance portion"]
#[doc = " @name: name of this parameter: always an interned string"]
#[doc = " @flags: #GParamFlags flags for this parameter"]
#[doc = " @value_type: the #GValue type for this parameter"]
#[doc = " @owner_type: #GType type that uses (introduces) this parameter"]
#[doc = ""]
#[doc = " All other fields of the GParamSpec struct are private and"]
#[doc = " should not be used directly."]
pub type GParamSpec = _GParamSpec;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)"]
#[doc = " @g_type_instance: private #GTypeInstance portion"]
#[doc = " @name: name of this parameter: always an interned string"]
#[doc = " @flags: #GParamFlags flags for this parameter"]
#[doc = " @value_type: the #GValue type for this parameter"]
#[doc = " @owner_type: #GType type that uses (introduces) this parameter"]
#[doc = ""]
#[doc = " All other fields of the GParamSpec struct are private and"]
#[doc = " should not be used directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[test]
fn bindgen_test_layout__GParamSpec() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpec>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).value_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).owner_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(owner_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._nick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_nick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._blurb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_blurb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).qdata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).ref_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).param_id as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(param_id)
        )
    );
}
#[doc = " GObject:"]
#[doc = ""]
#[doc = " The base object type."]
#[doc = ""]
#[doc = " All the fields in the `GObject` structure are private to the implementation"]
#[doc = " and should never be accessed directly."]
pub type GObject = _GObject;
#[doc = " GObjectClass:"]
#[doc = " @g_type_class: the parent class"]
#[doc = " @constructor: the @constructor function is called by g_object_new () to"]
#[doc = "  complete the object initialization after all the construction properties are"]
#[doc = "  set. The first thing a @constructor implementation must do is chain up to the"]
#[doc = "  @constructor of the parent class. Overriding @constructor should be rarely"]
#[doc = "  needed, e.g. to handle construct properties, or to implement singletons."]
#[doc = " @set_property: the generic setter for all properties of this type. Should be"]
#[doc = "  overridden for every type with properties. If implementations of"]
#[doc = "  @set_property don't emit property change notification explicitly, this will"]
#[doc = "  be done implicitly by the type system. However, if the notify signal is"]
#[doc = "  emitted explicitly, the type system will not emit it a second time."]
#[doc = " @get_property: the generic getter for all properties of this type. Should be"]
#[doc = "  overridden for every type with properties."]
#[doc = " @dispose: the @dispose function is supposed to drop all references to other"]
#[doc = "  objects, but keep the instance otherwise intact, so that client method"]
#[doc = "  invocations still work. It may be run multiple times (due to reference"]
#[doc = "  loops). Before returning, @dispose should chain up to the @dispose method"]
#[doc = "  of the parent class."]
#[doc = " @finalize: instance finalization function, should finish the finalization of"]
#[doc = "  the instance begun in @dispose and chain up to the @finalize method of the"]
#[doc = "  parent class."]
#[doc = " @dispatch_properties_changed: emits property change notification for a bunch"]
#[doc = "  of properties. Overriding @dispatch_properties_changed should be rarely"]
#[doc = "  needed."]
#[doc = " @notify: the class closure for the notify signal"]
#[doc = " @constructed: the @constructed function is called by g_object_new() as the"]
#[doc = "  final step of the object creation process.  At the point of the call, all"]
#[doc = "  construction properties have been set on the object.  The purpose of this"]
#[doc = "  call is to allow for object initialisation steps that can only be performed"]
#[doc = "  after construction properties have been set.  @constructed implementors"]
#[doc = "  should chain up to the @constructed call of their parent class to allow it"]
#[doc = "  to complete its initialisation."]
#[doc = ""]
#[doc = " The class structure for the GObject type."]
#[doc = ""]
#[doc = " |[<!-- language=\"C\" -->"]
#[doc = " // Example of implementing a singleton using a constructor."]
#[doc = " static MySingleton *the_singleton = NULL;"]
#[doc = ""]
#[doc = " static GObject*"]
#[doc = " my_singleton_constructor (GType                  type,"]
#[doc = "                           guint                  n_construct_params,"]
#[doc = "                           GObjectConstructParam *construct_params)"]
#[doc = " {"]
#[doc = "   GObject *object;"]
#[doc = ""]
#[doc = "   if (!the_singleton)"]
#[doc = "     {"]
#[doc = "       object = G_OBJECT_CLASS (parent_class)->constructor (type,"]
#[doc = "                                                            n_construct_params,"]
#[doc = "                                                            construct_params);"]
#[doc = "       the_singleton = MY_SINGLETON (object);"]
#[doc = "     }"]
#[doc = "   else"]
#[doc = "     object = g_object_ref (G_OBJECT (the_singleton));"]
#[doc = ""]
#[doc = "   return object;"]
#[doc = " }"]
#[doc = " ]|"]
pub type GObjectClass = _GObjectClass;
#[doc = " GObjectConstructParam:"]
#[doc = " @pspec: the #GParamSpec of the construct parameter"]
#[doc = " @value: the value to set the parameter to"]
#[doc = ""]
#[doc = " The GObjectConstructParam struct is an auxiliary structure used to hand"]
#[doc = " #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
pub type GObjectConstructParam = _GObjectConstructParam;
#[doc = " GObject:"]
#[doc = ""]
#[doc = " The base object type."]
#[doc = ""]
#[doc = " All the fields in the `GObject` structure are private to the implementation"]
#[doc = " and should never be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).ref_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).qdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
#[doc = " GObjectClass:"]
#[doc = " @g_type_class: the parent class"]
#[doc = " @constructor: the @constructor function is called by g_object_new () to"]
#[doc = "  complete the object initialization after all the construction properties are"]
#[doc = "  set. The first thing a @constructor implementation must do is chain up to the"]
#[doc = "  @constructor of the parent class. Overriding @constructor should be rarely"]
#[doc = "  needed, e.g. to handle construct properties, or to implement singletons."]
#[doc = " @set_property: the generic setter for all properties of this type. Should be"]
#[doc = "  overridden for every type with properties. If implementations of"]
#[doc = "  @set_property don't emit property change notification explicitly, this will"]
#[doc = "  be done implicitly by the type system. However, if the notify signal is"]
#[doc = "  emitted explicitly, the type system will not emit it a second time."]
#[doc = " @get_property: the generic getter for all properties of this type. Should be"]
#[doc = "  overridden for every type with properties."]
#[doc = " @dispose: the @dispose function is supposed to drop all references to other"]
#[doc = "  objects, but keep the instance otherwise intact, so that client method"]
#[doc = "  invocations still work. It may be run multiple times (due to reference"]
#[doc = "  loops). Before returning, @dispose should chain up to the @dispose method"]
#[doc = "  of the parent class."]
#[doc = " @finalize: instance finalization function, should finish the finalization of"]
#[doc = "  the instance begun in @dispose and chain up to the @finalize method of the"]
#[doc = "  parent class."]
#[doc = " @dispatch_properties_changed: emits property change notification for a bunch"]
#[doc = "  of properties. Overriding @dispatch_properties_changed should be rarely"]
#[doc = "  needed."]
#[doc = " @notify: the class closure for the notify signal"]
#[doc = " @constructed: the @constructed function is called by g_object_new() as the"]
#[doc = "  final step of the object creation process.  At the point of the call, all"]
#[doc = "  construction properties have been set on the object.  The purpose of this"]
#[doc = "  call is to allow for object initialisation steps that can only be performed"]
#[doc = "  after construction properties have been set.  @constructed implementors"]
#[doc = "  should chain up to the @constructed call of their parent class to allow it"]
#[doc = "  to complete its initialisation."]
#[doc = ""]
#[doc = " The class structure for the GObject type."]
#[doc = ""]
#[doc = " |[<!-- language=\"C\" -->"]
#[doc = " // Example of implementing a singleton using a constructor."]
#[doc = " static MySingleton *the_singleton = NULL;"]
#[doc = ""]
#[doc = " static GObject*"]
#[doc = " my_singleton_constructor (GType                  type,"]
#[doc = "                           guint                  n_construct_params,"]
#[doc = "                           GObjectConstructParam *construct_params)"]
#[doc = " {"]
#[doc = "   GObject *object;"]
#[doc = ""]
#[doc = "   if (!the_singleton)"]
#[doc = "     {"]
#[doc = "       object = G_OBJECT_CLASS (parent_class)->constructor (type,"]
#[doc = "                                                            n_construct_params,"]
#[doc = "                                                            construct_params);"]
#[doc = "       the_singleton = MY_SINGLETON (object);"]
#[doc = "     }"]
#[doc = "   else"]
#[doc = "     object = g_object_ref (G_OBJECT (the_singleton));"]
#[doc = ""]
#[doc = "   return object;"]
#[doc = " }"]
#[doc = " ]|"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub pdummy: [gpointer; 6usize],
}
#[test]
fn bindgen_test_layout__GObjectClass() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GObjectClass>())).construct_properties as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(construct_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).set_property as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).get_property as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).dispose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).finalize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GObjectClass>())).dispatch_properties_changed as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispatch_properties_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).notify as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructed as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).pdummy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pdummy)
        )
    );
}
#[doc = " GObjectConstructParam:"]
#[doc = " @pspec: the #GParamSpec of the construct parameter"]
#[doc = " @value: the value to set the parameter to"]
#[doc = ""]
#[doc = " The GObjectConstructParam struct is an auxiliary structure used to hand"]
#[doc = " #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[test]
fn bindgen_test_layout__GObjectConstructParam() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectConstructParam>(),
        16usize,
        concat!("Size of: ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectConstructParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).pspec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(pspec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResult {
    _unused: [u8; 0],
}
pub type GAsyncResult = _GAsyncResult;
pub type GCancellable = _GCancellable;
#[doc = " GAsyncReadyCallback:"]
#[doc = " @source_object: (nullable): the object the asynchronous operation was started with."]
#[doc = " @res: a #GAsyncResult."]
#[doc = " @user_data: user data passed to the callback."]
#[doc = ""]
#[doc = " Type definition for a function that will be called back when an asynchronous"]
#[doc = " operation within GIO has been completed. #GAsyncReadyCallback"]
#[doc = " callbacks from #GTask are guaranteed to be invoked in a later"]
#[doc = " iteration of the"]
#[doc = " [thread-default main context][g-main-context-push-thread-default]"]
#[doc = " where the #GTask was created. All other users of"]
#[doc = " #GAsyncReadyCallback must likewise call it asynchronously in a"]
#[doc = " later iteration of the main context."]
#[doc = ""]
#[doc = " The asynchronous operation is guaranteed to have held a reference to"]
#[doc = " @source_object from the time when the `*_async()` function was called, until"]
#[doc = " after this callback returns."]
pub type GAsyncReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(source_object: *mut GObject, res: *mut GAsyncResult, user_data: gpointer),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellablePrivate {
    _unused: [u8; 0],
}
pub type GCancellablePrivate = _GCancellablePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellable {
    pub parent_instance: GObject,
    pub priv_: *mut GCancellablePrivate,
}
#[test]
fn bindgen_test_layout__GCancellable() {
    assert_eq!(
        ::std::mem::size_of::<_GCancellable>(),
        32usize,
        concat!("Size of: ", stringify!(_GCancellable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCancellable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCancellable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellable>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellable>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(priv_)
        )
    );
}
pub type LightDMGreeter = _LightDMGreeter;
pub type LightDMGreeterClass = _LightDMGreeterClass;
pub const LightDMPromptType_LIGHTDM_PROMPT_TYPE_QUESTION: LightDMPromptType = 0;
pub const LightDMPromptType_LIGHTDM_PROMPT_TYPE_SECRET: LightDMPromptType = 1;
#[doc = " LightDMPromptType:"]
#[doc = " @LIGHTDM_PROMPT_TYPE_QUESTION: prompt is a question.  The information can be shown as it is entered."]
#[doc = " @LIGHTDM_PROMPT_TYPE_SECRET: prompt is for secret information.  The entered information should be obscured so it can't be publically visible."]
#[doc = ""]
#[doc = " Prompt types the client is required to display."]
pub type LightDMPromptType = ::std::os::raw::c_uint;
extern "C" {
    pub fn lightdm_prompt_type_get_type() -> GType;
}
pub const LightDMMessageType_LIGHTDM_MESSAGE_TYPE_INFO: LightDMMessageType = 0;
pub const LightDMMessageType_LIGHTDM_MESSAGE_TYPE_ERROR: LightDMMessageType = 1;
#[doc = " LightDMMessageType:"]
#[doc = " @LIGHTDM_MESSAGE_TYPE_INFO: Informational message."]
#[doc = " @LIGHTDM_MESSAGE_TYPE_ERROR: Error message."]
pub type LightDMMessageType = ::std::os::raw::c_uint;
extern "C" {
    pub fn lightdm_message_type_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMGreeter {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__LightDMGreeter() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMGreeter>(),
        24usize,
        concat!("Size of: ", stringify!(_LightDMGreeter))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMGreeter>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMGreeter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMGreeter>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeter),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMGreeterClass {
    pub parent_class: GObjectClass,
    pub show_message: ::std::option::Option<
        unsafe extern "C" fn(
            greeter: *mut LightDMGreeter,
            text: *const gchar,
            type_: LightDMMessageType,
        ),
    >,
    pub show_prompt: ::std::option::Option<
        unsafe extern "C" fn(
            greeter: *mut LightDMGreeter,
            text: *const gchar,
            type_: LightDMPromptType,
        ),
    >,
    pub authentication_complete:
        ::std::option::Option<unsafe extern "C" fn(greeter: *mut LightDMGreeter)>,
    pub autologin_timer_expired:
        ::std::option::Option<unsafe extern "C" fn(greeter: *mut LightDMGreeter)>,
    pub idle: ::std::option::Option<unsafe extern "C" fn(greeter: *mut LightDMGreeter)>,
    pub reset: ::std::option::Option<unsafe extern "C" fn(greeter: *mut LightDMGreeter)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__LightDMGreeterClass() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMGreeterClass>(),
        216usize,
        concat!("Size of: ", stringify!(_LightDMGreeterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMGreeterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMGreeterClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMGreeterClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMGreeterClass>())).show_message as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(show_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMGreeterClass>())).show_prompt as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(show_prompt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMGreeterClass>())).authentication_complete as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(authentication_complete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMGreeterClass>())).autologin_timer_expired as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(autologin_timer_expired)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMGreeterClass>())).idle as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMGreeterClass>())).reset as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMGreeterClass>())).reserved1 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMGreeterClass>())).reserved2 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMGreeterClass>())).reserved3 as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMGreeterClass>())).reserved4 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMGreeterClass),
            "::",
            stringify!(reserved4)
        )
    );
}
pub type LightDMGreeter_autoptr = *mut LightDMGreeter;
pub const LightDMGreeterError_LIGHTDM_GREETER_ERROR_COMMUNICATION_ERROR: LightDMGreeterError = 0;
pub const LightDMGreeterError_LIGHTDM_GREETER_ERROR_CONNECTION_FAILED: LightDMGreeterError = 1;
pub const LightDMGreeterError_LIGHTDM_GREETER_ERROR_SESSION_FAILED: LightDMGreeterError = 2;
pub const LightDMGreeterError_LIGHTDM_GREETER_ERROR_NO_AUTOLOGIN: LightDMGreeterError = 3;
pub const LightDMGreeterError_LIGHTDM_GREETER_ERROR_INVALID_USER: LightDMGreeterError = 4;
#[doc = " LightDMGreeterError:"]
#[doc = " @LIGHTDM_GREETER_ERROR_COMMUNICATION_ERROR: error communicating with daemon."]
#[doc = " @LIGHTDM_GREETER_ERROR_CONNECTION_FAILED: failed to connect to the daemon."]
#[doc = " @LIGHTDM_GREETER_ERROR_SESSION_FAILED: requested session failed to start."]
#[doc = " @LIGHTDM_GREETER_ERROR_NO_AUTOLOGIN: autologin not configured."]
#[doc = " @LIGHTDM_GREETER_ERROR_INVALID_USER: autologin not configured."]
#[doc = ""]
#[doc = " Error codes returned by greeter operations."]
pub type LightDMGreeterError = ::std::os::raw::c_uint;
extern "C" {
    pub fn lightdm_greeter_error_quark() -> GQuark;
}
extern "C" {
    pub fn lightdm_greeter_error_get_type() -> GType;
}
extern "C" {
    pub fn lightdm_greeter_get_type() -> GType;
}
extern "C" {
    pub fn lightdm_greeter_new() -> *mut LightDMGreeter;
}
extern "C" {
    pub fn lightdm_greeter_set_resettable(greeter: *mut LightDMGreeter, resettable: gboolean);
}
extern "C" {
    pub fn lightdm_greeter_connect_to_daemon(
        greeter: *mut LightDMGreeter,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn lightdm_greeter_connect_to_daemon_finish(
        greeter: *mut LightDMGreeter,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_connect_to_daemon_sync(
        greeter: *mut LightDMGreeter,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_hint(
        greeter: *mut LightDMGreeter,
        name: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn lightdm_greeter_get_default_session_hint(greeter: *mut LightDMGreeter) -> *const gchar;
}
extern "C" {
    pub fn lightdm_greeter_get_hide_users_hint(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_show_manual_login_hint(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_show_remote_login_hint(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_lock_hint(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_has_guest_account_hint(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_select_user_hint(greeter: *mut LightDMGreeter) -> *const gchar;
}
extern "C" {
    pub fn lightdm_greeter_get_select_guest_hint(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_autologin_user_hint(greeter: *mut LightDMGreeter) -> *const gchar;
}
extern "C" {
    pub fn lightdm_greeter_get_autologin_session_hint(greeter: *mut LightDMGreeter)
        -> *const gchar;
}
extern "C" {
    pub fn lightdm_greeter_get_autologin_guest_hint(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_autologin_timeout_hint(greeter: *mut LightDMGreeter) -> gint;
}
extern "C" {
    pub fn lightdm_greeter_cancel_autologin(greeter: *mut LightDMGreeter);
}
extern "C" {
    pub fn lightdm_greeter_authenticate(
        greeter: *mut LightDMGreeter,
        username: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_authenticate_as_guest(
        greeter: *mut LightDMGreeter,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_authenticate_autologin(
        greeter: *mut LightDMGreeter,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_authenticate_remote(
        greeter: *mut LightDMGreeter,
        session: *const gchar,
        username: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_respond(
        greeter: *mut LightDMGreeter,
        response: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_cancel_authentication(
        greeter: *mut LightDMGreeter,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_in_authentication(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_is_authenticated(greeter: *mut LightDMGreeter) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_get_authentication_user(greeter: *mut LightDMGreeter) -> *const gchar;
}
extern "C" {
    pub fn lightdm_greeter_set_language(
        greeter: *mut LightDMGreeter,
        language: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_start_session(
        greeter: *mut LightDMGreeter,
        session: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn lightdm_greeter_start_session_finish(
        greeter: *mut LightDMGreeter,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_start_session_sync(
        greeter: *mut LightDMGreeter,
        session: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn lightdm_greeter_ensure_shared_data_dir(
        greeter: *mut LightDMGreeter,
        username: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn lightdm_greeter_ensure_shared_data_dir_finish(
        greeter: *mut LightDMGreeter,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn lightdm_greeter_ensure_shared_data_dir_sync(
        greeter: *mut LightDMGreeter,
        username: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn lightdm_greeter_connect_sync(
        greeter: *mut LightDMGreeter,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type LightDMLanguage = _LightDMLanguage;
pub type LightDMLanguageClass = _LightDMLanguageClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMLanguage {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__LightDMLanguage() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMLanguage>(),
        24usize,
        concat!("Size of: ", stringify!(_LightDMLanguage))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMLanguage>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMLanguage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMLanguage>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguage),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMLanguageClass {
    pub parent_class: GObjectClass,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__LightDMLanguageClass() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMLanguageClass>(),
        184usize,
        concat!("Size of: ", stringify!(_LightDMLanguageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMLanguageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMLanguageClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMLanguageClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLanguageClass>())).reserved1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguageClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLanguageClass>())).reserved2 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguageClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLanguageClass>())).reserved3 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguageClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLanguageClass>())).reserved4 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguageClass),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLanguageClass>())).reserved5 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguageClass),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLanguageClass>())).reserved6 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLanguageClass),
            "::",
            stringify!(reserved6)
        )
    );
}
pub type LightDMLanguage_autoptr = *mut LightDMLanguage;
extern "C" {
    pub fn lightdm_language_get_type() -> GType;
}
extern "C" {
    pub fn lightdm_get_languages() -> *mut GList;
}
extern "C" {
    pub fn lightdm_get_language() -> *mut LightDMLanguage;
}
extern "C" {
    pub fn lightdm_language_get_code(language: *mut LightDMLanguage) -> *const gchar;
}
extern "C" {
    pub fn lightdm_language_get_name(language: *mut LightDMLanguage) -> *const gchar;
}
extern "C" {
    pub fn lightdm_language_get_territory(language: *mut LightDMLanguage) -> *const gchar;
}
extern "C" {
    pub fn lightdm_language_matches(language: *mut LightDMLanguage, code: *const gchar)
        -> gboolean;
}
pub type LightDMLayout = _LightDMLayout;
pub type LightDMLayoutClass = _LightDMLayoutClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMLayout {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__LightDMLayout() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMLayout>(),
        24usize,
        concat!("Size of: ", stringify!(_LightDMLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMLayout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLayout>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayout),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMLayoutClass {
    pub parent_class: GObjectClass,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__LightDMLayoutClass() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMLayoutClass>(),
        184usize,
        concat!("Size of: ", stringify!(_LightDMLayoutClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMLayoutClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMLayoutClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMLayoutClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayoutClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLayoutClass>())).reserved1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayoutClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLayoutClass>())).reserved2 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayoutClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLayoutClass>())).reserved3 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayoutClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLayoutClass>())).reserved4 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayoutClass),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLayoutClass>())).reserved5 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayoutClass),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMLayoutClass>())).reserved6 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMLayoutClass),
            "::",
            stringify!(reserved6)
        )
    );
}
pub type LightDMLayout_autoptr = *mut LightDMLayout;
extern "C" {
    pub fn lightdm_layout_get_type() -> GType;
}
extern "C" {
    pub fn lightdm_get_layouts() -> *mut GList;
}
extern "C" {
    pub fn lightdm_set_layout(layout: *mut LightDMLayout);
}
extern "C" {
    pub fn lightdm_get_layout() -> *mut LightDMLayout;
}
extern "C" {
    pub fn lightdm_layout_get_name(layout: *mut LightDMLayout) -> *const gchar;
}
extern "C" {
    pub fn lightdm_layout_get_short_description(layout: *mut LightDMLayout) -> *const gchar;
}
extern "C" {
    pub fn lightdm_layout_get_description(layout: *mut LightDMLayout) -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_can_suspend() -> gboolean;
}
extern "C" {
    pub fn lightdm_suspend(error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn lightdm_get_can_hibernate() -> gboolean;
}
extern "C" {
    pub fn lightdm_hibernate(error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn lightdm_get_can_restart() -> gboolean;
}
extern "C" {
    pub fn lightdm_restart(error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn lightdm_get_can_shutdown() -> gboolean;
}
extern "C" {
    pub fn lightdm_shutdown(error: *mut *mut GError) -> gboolean;
}
pub type LightDMSession = _LightDMSession;
pub type LightDMSessionClass = _LightDMSessionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMSession {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__LightDMSession() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMSession>(),
        24usize,
        concat!("Size of: ", stringify!(_LightDMSession))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMSession>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMSession))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMSession>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSession),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMSessionClass {
    pub parent_class: GObjectClass,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__LightDMSessionClass() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMSessionClass>(),
        184usize,
        concat!("Size of: ", stringify!(_LightDMSessionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMSessionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMSessionClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMSessionClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSessionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMSessionClass>())).reserved1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSessionClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMSessionClass>())).reserved2 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSessionClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMSessionClass>())).reserved3 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSessionClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMSessionClass>())).reserved4 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSessionClass),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMSessionClass>())).reserved5 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSessionClass),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMSessionClass>())).reserved6 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMSessionClass),
            "::",
            stringify!(reserved6)
        )
    );
}
pub type LightDMSession_autoptr = *mut LightDMSession;
extern "C" {
    pub fn lightdm_session_get_type() -> GType;
}
extern "C" {
    pub fn lightdm_get_sessions() -> *mut GList;
}
extern "C" {
    pub fn lightdm_get_remote_sessions() -> *mut GList;
}
extern "C" {
    pub fn lightdm_session_get_key(session: *mut LightDMSession) -> *const gchar;
}
extern "C" {
    pub fn lightdm_session_get_session_type(session: *mut LightDMSession) -> *const gchar;
}
extern "C" {
    pub fn lightdm_session_get_name(session: *mut LightDMSession) -> *const gchar;
}
extern "C" {
    pub fn lightdm_session_get_comment(session: *mut LightDMSession) -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_hostname() -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_os_id() -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_os_name() -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_os_pretty_name() -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_os_version() -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_os_version_id() -> *const gchar;
}
extern "C" {
    pub fn lightdm_get_motd() -> *mut gchar;
}
pub type LightDMUserList = _LightDMUserList;
pub type LightDMUserListClass = _LightDMUserListClass;
pub type LightDMUser = _LightDMUser;
pub type LightDMUserClass = _LightDMUserClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMUser {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__LightDMUser() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMUser>(),
        24usize,
        concat!("Size of: ", stringify!(_LightDMUser))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMUser>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMUser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUser>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUser),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMUserClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(user: *mut LightDMUser)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__LightDMUserClass() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMUserClass>(),
        192usize,
        concat!("Size of: ", stringify!(_LightDMUserClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMUserClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMUserClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).changed as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).reserved1 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).reserved2 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).reserved3 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).reserved4 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).reserved5 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserClass>())).reserved6 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserClass),
            "::",
            stringify!(reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMUserList {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__LightDMUserList() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMUserList>(),
        24usize,
        concat!("Size of: ", stringify!(_LightDMUserList))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMUserList>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMUserList))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMUserList>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserList),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LightDMUserListClass {
    pub parent_class: GObjectClass,
    pub user_added: ::std::option::Option<
        unsafe extern "C" fn(user_list: *mut LightDMUserList, user: *mut LightDMUser),
    >,
    pub user_changed: ::std::option::Option<
        unsafe extern "C" fn(user_list: *mut LightDMUserList, user: *mut LightDMUser),
    >,
    pub user_removed: ::std::option::Option<
        unsafe extern "C" fn(user_list: *mut LightDMUserList, user: *mut LightDMUser),
    >,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__LightDMUserListClass() {
    assert_eq!(
        ::std::mem::size_of::<_LightDMUserListClass>(),
        208usize,
        concat!("Size of: ", stringify!(_LightDMUserListClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_LightDMUserListClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_LightDMUserListClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMUserListClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMUserListClass>())).user_added as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(user_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMUserListClass>())).user_changed as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(user_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LightDMUserListClass>())).user_removed as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(user_removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserListClass>())).reserved1 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserListClass>())).reserved2 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserListClass>())).reserved3 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserListClass>())).reserved4 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserListClass>())).reserved5 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LightDMUserListClass>())).reserved6 as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_LightDMUserListClass),
            "::",
            stringify!(reserved6)
        )
    );
}
pub type LightDMUser_autoptr = *mut LightDMUser;
pub type LightDMUserList_autoptr = *mut LightDMUserList;
extern "C" {
    pub fn lightdm_user_list_get_type() -> GType;
}
extern "C" {
    pub fn lightdm_user_get_type() -> GType;
}
extern "C" {
    pub fn lightdm_user_list_get_instance() -> *mut LightDMUserList;
}
extern "C" {
    pub fn lightdm_user_list_get_length(user_list: *mut LightDMUserList) -> gint;
}
extern "C" {
    pub fn lightdm_user_list_get_user_by_name(
        user_list: *mut LightDMUserList,
        username: *const gchar,
    ) -> *mut LightDMUser;
}
extern "C" {
    pub fn lightdm_user_list_get_users(user_list: *mut LightDMUserList) -> *mut GList;
}
extern "C" {
    pub fn lightdm_user_get_name(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_real_name(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_display_name(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_home_directory(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_image(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_background(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_language(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_layout(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_layouts(user: *mut LightDMUser) -> *const *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_session(user: *mut LightDMUser) -> *const gchar;
}
extern "C" {
    pub fn lightdm_user_get_logged_in(user: *mut LightDMUser) -> gboolean;
}
extern "C" {
    pub fn lightdm_user_get_has_messages(user: *mut LightDMUser) -> gboolean;
}
extern "C" {
    pub fn lightdm_user_get_uid(user: *mut LightDMUser) -> uid_t;
}
extern "C" {
    pub fn lightdm_user_get_is_locked(user: *mut LightDMUser) -> gboolean;
}
